---
title: "Using matchRanges"
author: "Eric S. Davis"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
output:
  rmarkdown::html_document:
    highlight: tango
    toc: true
    toc_float: true	
    fig_width: 5
    fig_height: 3
vignette: |
  %\VignetteIndexEntry{Using matchRanges}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

In this vignette, we demonstrate the generation of covariate-matched null ranges by using the `matchRanges()` function to test the "covergence rule" of CTCF-bound chromatin loops, first described in Rao et al. 2014. In addition to this complex use case, we also provide usage examples for accessor functions for the `Matched` subclasses and a guide for selecting among the provided matching methods.

## Background

In 2014, in situ Hi-C was used to probe the spatial organization of the human genome and identify 3D structures - such as chromatin loops - characterized by high contact frequency. Chromatin loops can be formed by loop-extrusion, where the ring-like cohesin complex extrudes chromatin until stopped by a bound CTCF transcription factor. Therefore, most validated loops are bound at both ends by a CTCF motif. The convergence rule purports that the vast majority (\>90%) of CTCF-bound loops occur in a convergent orientation, where the asymetric CTCF motifs at each anchor face one another. This is a highly significant finding since we would only expect to find convergently-oriented CTCF motifs 25% of the time by chance.

## Approach

Here, we generate a set of null-hypothesis ranges to more rigorously test the convergence rule. First, we divide the genome into 10Kb bins and generate a representation of all pairs of bins within 1Mb of each other. Then, we annotate each pair of bins with potentially confounding covariates such as:

-   The number of CTCF sites in each bin.
-   The total CTCF signal in each bin.
-   The number of intervening CTCF sites between each bin pair.
-   The direction of each CTCF motif.
-   The prescence or absence of a loop between each bin pair.

Using these annotations and the `matchRanges()` function, we can compare CTCF motif orientations between pairs of genomic regions that are 1) connected by loops, 2) not connected by loops, 3) randomly chosen, or 4) not connected by loops, but matched for the number and strength of CTCF sites at and between loop anchors.

## Loading and formatting data

To test the convergence rule we will use data from the GM12878 cell line aligned to hg19. Loop annotations come from the original Rao et al. 2014 paper (accessed from the Gene Expression Omnibus (GEO) via accession number [GSE63525](http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE63525)), CTCF `.narrowpeak` files come from the Encode Consortium (accessed via AnnotationHub), and CTCF motif locations and orientations come from Mikhail Dozmorov's [CTCF AnnotationHub package](https://github.com/mdozmorov/CTCF).

First we can load and format loops by converting them to GInteractions objects, converting the seqlevels to "UCSC" format, and resizing all loop anchors to 10Kb.

```{r, message=FALSE, warning=FALSE}
## Load packages
library(nullranges)
library(GenomicRanges)
library(InteractionSet)
library(plyranges)
library(magrittr)
library(data.table)

## Loop file from nullranges
loopFile <- "extdata/GSE63525_GM12878_primary+replicate_HiCCUPS_looplist.txt.gz"

## Read loops
loops <-
  loopFile %>%
  system.file(package = "nullranges") %>%
  fread() %>%
  hictoolsr::as_ginteractions(keep.extra.columns = FALSE) %>%
  GenomeInfoDb::`seqlevelsStyle<-`("UCSC") %>%
  hictoolsr::binBedpe(res = 10e3, a1Pos = 'center', a2Pos = 'center') %>%
  unique()

## Adjust for 0-based start positions
regions(loops) %<>% mutate(start = start + 1)

loops
```

We can use AnnotationHub to query then select `.narrowPeak` files that contain peak calls from CTCF ChIP-seq experiments.

```{r, message=FALSE, warning=FALSE}
## Load AnnotationHub
library(AnnotationHub)
ah <- AnnotationHub()

## Search for the appropriate file
query(ah, c("CTCF", "GM12878", "narrowPeak"))

## Select a narrowPeak file
ctcfPeaks <- ah[["AH22521"]]

ctcfPeaks
```

We can load CTCF motif location and orientation information from Mikhail Dozmorov's CTCF package (TODO: replace this with AnnotationHub when available).

```{r}
## Load CTCF motif GRanges object
load(system.file("extdata/CTCF_hg19.RData", package = "nullranges"))

## Rename to ctcfMotifs
ctcfMotifs <- CTCF_hg19

## Copy strand information to metadata (for downstream overlaps)
ctcfMotifs$direction <- as.character(strand(ctcfMotifs))

ctcfMotifs
```

Finally, we can subset our CTCF motifs by keeping those that fall into a GM12878 CTCF ChIP-seq peak.

```{r, message=FALSE}
## Intersect peak and motifs
ov <- findOverlaps(ctcfMotifs, ctcfPeaks)

## Subset by overlaps
ctcfMotifs <- ctcfMotifs[queryHits(ov)]

## Add signalValue to ctcfMotifs
ctcfMotifs$signalValue <- ctcfPeaks[subjectHits(ov)]$signalValue

ctcfMotifs
```

## Binning the genome and generating bin-pairs

Since multiple CTCF sites may fall into a single 10Kb loop anchor, how do we choose which site to use for our comparison? We can avoid choosing a specific site by dividing the genome into 10Kb bins and finding all combinations of bins within some distance (in this case 1Mb).

We can use `TxDb` and `tileGenome` to split the genome into 10Kb bins and generate all pairs of bins within 1Mb regions.

```{r, message=FALSE, warning=FALSE}
## Load TxDb & filter for standard chromosomes
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- 
  TxDb.Hsapiens.UCSC.hg19.knownGene %>%
  GenomeInfoDb::keepStandardChromosomes() %>%
  GenomeInfoDb::dropSeqlevels("chrM")

## Create 10Kb bins across the genome
bins <- tileGenome(seqinfo(txdb), tilewidth = 10e3, cut.last.tile.in.chrom = TRUE)

bins
```

However, since we are only interested in CTCF-bound regions, we can filter out the vast majority of these bins

```{r}
## Filter out bins that don't have a CTCF site
bins <- subsetByOverlaps(bins, ctcfMotifs)
```

before generating all combinations of bins within 1Mb.

```{r, message=FALSE}
## Define 1Mb regions around each bin
regions <-
  bins %>%
  sort() %>%
  resize(width = 1e6, fix = 'start') %>%
  suppressWarnings() %>%
  trim()

## Group 10Kb bins by each 1Mb region that contain them
ov <- 
  findOverlaps(bins, regions, type = 'within') %>%
  as.data.table() %>%
  `colnames<-`(c("bins", "regions"))

## Order by regions
ov <- ov[order(regions)]

## Iterate over combinations
ov2 <- ov[, .(bins[1], bins[-1]), by = regions]

## Remove NA's (last value for each chromosome)
ov2 <- na.omit(ov2)

## Convert coordinates to GInteractions object
binPairs <- 
  GInteractions(anchor1 = ov2$V1,
                anchor2 = ov2$V2,
                regions = bins,
                mode = 'strict')

binPairs
```

## Annotating features

We can annotate our `binPairs` object with the covariates of interest. For example, bin-pairs can be annotated with the presence/absence of a looping interaction, all CTCF sites can be overlapped with each bin and annotated with number of CTCF sites, total CTCF signal, direction of each CTCF motif, and the number of intervening CTCF sites between each bin pair.

Lets start by summarizing CTCF motif data by overlapping with our bins.

```{r}
## Summarize CTCF motifs by bin
bin_df <- 
  bins %>%
  group_by_overlaps(ctcfMotifs) %>%
  summarize(totalSignal = sum(signalValue),
            direction = direction,
            hasPlus = any(direction %in% '+'),
            hasMinus = any(direction %in% '-'),
            n_sites = n())

## Initialize empty metadata
mcols(bins) <- DataFrame(totalSignal = 0,
                         direction = CharacterList('*'),
                         hasPlus = FALSE,
                         hasMinus = FALSE,
                         n_sites = 0)

## Add summarized data to bins
mcols(bins[bin_df$query]) <- bin_df[-1]

bins[bin_df$query]
```

Now we can reconstruct our `binPairs` object with our CTCF motif data stored in the `regions` slot, and extract each anchor.

```{r}
## Reconstruct bin-pairs
regions(binPairs) <- bins

## Extract each anchor of binPairs
a1 <- anchors(binPairs, 'first')
a2 <- anchors(binPairs, 'second')
```

Finally, we can add our covariates of interest to our `binPairs` object:

```{r}
## Annotate looped bin-pairs
binPairs$looped[countOverlaps(binPairs, loops) == 0] <- FALSE
binPairs$looped[countOverlaps(binPairs, loops) == 1] <- TRUE

## Add totalSignal from both anchors
binPairs$totalSignal <- log2(a1$totalSignal + a2$totalSignal + 1)

## Add total number of CTCF sites from both anchors
binPairs$n_sites <- a1$n_sites + a2$n_sites

## Add number of intervening CTCF sites
gaps <- GRanges(seqnames = seqnames(a1),
                ranges = IRanges(start = end(a1),
                                 end = start(a2)))

binPairs$n_intervening_sites <- countOverlaps(gaps, ctcfMotifs)

## Distance
binPairs$distance <- pairdist(binPairs)

## Denote convergent CTCF sites
binPairs$convergent <- FALSE
binPairs$convergent[(a1$hasPlus & a2$hasMinus) |
                    (a2$hasPlus & a1$hasMinus)] <- TRUE
```

This leaves us with a GInteractions object with all potential covariates:

```{r}
binPairs[binPairs$looped]
binPairs[!binPairs$looped]
```

## Generate matched control set

Now that we have a GInteractions object annotated with covariates of interest, let's use the `matchRanges()` function to generate a null-hypothesis set of ranges with which to compare our looped bin-pairs.

Let's start by defining our focal set (i.e. looped bin-pairs), our pool set (i.e un-looped bin-pairs), and our covariates of interest (i.e. `totalSignal`, `n_sites`, and `n_intervening_sites`):

```{r}
## Define focal, pool, and covariates
focal <- binPairs[binPairs$looped]
pool  <- binPairs[!binPairs$looped]
# covar <- ~totalSignal + n_sites + n_intervening_sites
covar <- ~totalSignal + distance

combnCov(x = c('totalSignal', 'distance'))
```

Then we can generate our matched GInteractions bin-pairs:

```{r}
## Matched GInteractions
system.time({
  mgi <- matchRanges(focal, pool, covar, method = 'rejection', replace = FALSE)
})

## Inspect overview of matching
overview(mgi)

## Visualize covariate distribution matching quality
nullranges::plotPropensity(mgi, type = 'lines') + ggplot2::xlim(0, 0.1)


covariates(mgi)
plotCovariates(mgi, covar = 'totalSignal', type = 'lines', logTransform = TRUE)
plotCovariates(mgi, covar = 'distance', type = 'lines', logTransform = FALSE)
plotCovariates(mgi, covar = 'n_sites', type = 'lines')
plotCovariates(mgi, covar = 'n_intervening_sites', type = 'lines', logTransform = TRUE)

```

## Compare CTCF site orientation

Using our matched ranges, we can compare the percent of looped pairs with at least one convergent CTCF site against unlooped pairs and pairs that are unlooped but have been matched for our covariates.

```{r, fig.width=4, fig.height=4, fig.align='center'}
## Calculate the percent of convergent CTCF sites for each group
g1 <- (sum(focal(mgi)$convergent) / length(focal(mgi)))*100
g2 <- (sum(pool(mgi)$convergent) / length(pool(mgi)))*100
g3 <- (sum(mgi$convergent) / length(mgi))*100

## Visualize
barplot(height = c(g1, g2, g3),
        names.arg = c('looped', 'unlooped', 'matched'),
        col = c('#1F78B4', '#33A02C', '#A6CEE3'), 
        ylab = "Convergent CTCF Sites (%)",
        main = "Testing the Convergence Rule")

median(focal(mgi)$n_sites)
mean(focal(mgi)$n_sites)

```

## Visualizing CTCF-bound sites

Lets visualize the contact-frequency between looped CTCF sites, unlooped CTCF sites, and matched control CTCF sites. We can then further break this down into
