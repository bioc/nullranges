---
title: "Segmented block bootstrap"
author: "Wancen Mu"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
output:
  rmarkdown::html_document:
    highlight: tango
    toc: true
    toc_float: true	
    fig_width: 5
    fig_height: 3
vignette: |
  %\VignetteIndexEntry{Segmented block bootstrap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction to segmented block bootstrap

cite Bickel et al...

Options:

* Segment genome using feature density, e.g. gene density
* Use exiting segmentation (e.g. ChromHMM, etc.)

# Segmentation by gene density

First we obtain the Ensembl genes ...

```{r}
library(EnsDb.Hsapiens.v86)
edb <- EnsDb.Hsapiens.v86
filt <- AnnotationFilterList(GeneIdFilter("ENSG", "startsWith"))
g <- genes(edb, filter = filt)
```

```{r}
library(GenomeInfoDb)
g <- keepStandardChromosomes(g, pruning.mode = "coarse")
seqlevelsStyle(g) <- "UCSC"
seqlevels(g, pruning.mode="coarse") <- setdiff(seqlevels(g), "chrM")
g <- sortSeqlevels(g)
g <- sort(g)
table(seqnames(g))
```

## Import deny region

Deny regions ... cite Kundaje

```{r}
library(nullrangesData)
data("deny")
table(seqnames(deny))
```

```{r}
library(nullranges)
library(plyranges)
```

## CBS segmentation

We subset the deny ranges to those which are 500 bp or larger.

cite: DNAcopy paper

```{r seg-cbs}
deny2 <- deny %>% plyranges::filter(width(deny) >= 500)
L_s <- 1e6
out <- segmentDensity(g, n = 3, L_s = L_s,
                       deny = deny2, type = "cbs", returnPlot = TRUE)
seg <- out$seg
print(out$p1)
print(out$p2)
```

## Alternatively: HMM segmentation

cite: RcppHMM

```{r seg-hmm}
out_hmm <- segmentDensity(g, n = 3, L_s = L_s,
                           deny = deny2, type = "hmm",returnPlot = TRUE)
print(out_hmm$p1)
print(out_hmm$p2)
```

# Segmented block bootstrap within chromosome

# Timing on DHS peaks

*DHSA549Hg38* First download DNase hypersensitivity peaks in A549 from
*AnnotationHub*, then subset to standard chromosomes and remove mitochondria (more work
needed to handle these cases internally). We use a "chain file" from UCSC to move the ranges from hg19 to the modern hg38 to be consistent with gene ranges. Finally, we sort the
features to be bootstrapped.

```{r}
data("DHSA549Hg38")
table(seqnames(DHSA549Hg38))
```

Here we apply a segmented block bootstrap with blocks of size 500kb,
to the peaks...

Test on 10 times bootstrap ~13s

```{r eval=FALSE}
L_b <- 5e5
system.time({
  res_wochr <- segBootstrapRanges(seg, DHSA549Hg38, L_b, deny, R = 10, proportion_length = FALSE)
})
system.time({
  res_wochr <- segBootstrapRanges(seg, DHSA549Hg38, L_b, deny, deny_option = "trim", R = 10, proportion_length = FALSE)
})
system.time({
  res_wochr_propl <- segBootstrapRanges(seg, DHSA549Hg38, L_b, deny, R = 10)
})
system.time({
  res_wchr <- segBootstrapRanges(seg, DHSA549Hg38, L_b, deny, R = 10,
                                    within_chrom = TRUE, proportion_length = FALSE)
})
system.time({
  res_wchr <- segBootstrapRanges(seg, DHSA549Hg38, L_b, deny, R = 10,
                                    within_chrom = TRUE, proportion_length = TRUE)
  })
```

# Test performance on grid of segmentation and block lengths

TODO: this may not be ideal for the vignette, but better for a paper

```{r eval=FALSE}
L_s <- c(5e5, 1e6, 5e6)
L_b <- c(1e5, 5e5, 1e6)
mapply(function(L_s, L_b) {
  seg <- segment_density(g, n = 3, L_s = L_s,deny = deny2, type = "cbs",plot_segment = FALSE)
  res <- seg_bootstrap_granges(seg, g, L_b, R = 1,
                                     within_chrom = FALSE, proportion_length = FALSE)
  res <- res[[1]]
  ## gene density for origin ranges
  query <- tileGenome(seqlengths(g)[seqnames(g)@values],
                      tilewidth = L_s,
                      cut.last.tile.in.chrom = TRUE)
  ## gap will create whole chromosome length ranges
  gap <- gaps(deny2,end = seqlengths(g)) %>%
    plyranges::filter(strand=="*") 
  ## the region remove deny regions
  query_accept <- plyranges::join_overlap_intersect(query,gap) %>%
    filter(width > L_s / 100)
  counts_nostand <- countOverlaps(query_accept, g, minoverlap = 8)
  counts <- counts_nostand/width(query_accept) * L_s
  eps <- rnorm(length(counts), 0, .2)
  print(hist(counts, breaks = seq(0,600,30), xlab = paste(L_s, "with", L_b, "block size")))
  print(plot(sqrt(counts) + eps))
  ## gene density for bootstraps ranges
  query <- tileGenome(seqlengths(res)[seqnames(res)@values],
                      tilewidth = L_s,
                      cut.last.tile.in.chrom = TRUE)
  ## gap will create whole chromosome length ranges
  gap <- gaps(deny2,end = seqlengths(res)) %>%
    plyranges::filter(strand=="*") 
  ## the region remove deny regions
  query_accept <- plyranges::join_overlap_intersect(query,gap) %>%
    filter(width > L_s / 100)
  counts_nostand <- countOverlaps(query_accept, res, minoverlap = 8)
  counts <- counts_nostand/width(query_accept) * L_s
  eps <- rnorm(length(counts), 0, .2)
  print(hist(counts, breaks = 50, xlab = paste(L_s, "with", L_b, "block size")))
  print(plot(sqrt(counts) + eps))
}, L_s, L_b)
```

# Visualizing the segmented block bootstrap

Toy example for evaluating segmented block bootstrap...

```{r}
suppressPackageStartupMessages(library(BentoBox))
plotGRanges <- function(gr) {
  bb_pageCreate(width = 5, height = 2, xgrid = 0,
                ygrid = 0, showGuides = FALSE)
  for (i in seq_along(seqlevels(gr))) {
    chrom <- seqlevels(gr)[i]
    chromend <- seqlengths(gr)[[chrom]]
    suppressMessages({
      p <- bb_params(chromstart = 0, chromend = chromend,
                     x = 0.5, width = 4*chromend/500, height = 0.6,
                     at = seq(0, chromend, 50),
                     fill = cols)
      pbed <- bb_plotBed(data = gr, params = p,
                         chrom = chrom,
                         y = 0.6 + (i-1),
                         just = c("left", "bottom"),
                         colorby=colorby("state_col"))
      bb_annoGenomeLabel(plot = pbed, params = p, y = 0.7 + (i-1))
    })
  }
}
```

```{r}
library(GenomicRanges)
seq_nms <- rep(c("chr1","chr2"), c(4,3))
seg <- GRanges(
  seqnames = seq_nms,
  IRanges(start = c(1, 101, 201, 401, 1, 201, 301),
          width = c(100, 100, 200, 100, 200, 100, 100)),
  seqlengths=c(chr1=500,chr2=400),
  state = c(1,2,1,3,3,2,1),
  state_col = c(1,2,4,3,6,5,7)
)
```

```{r toysegments}
cols <- c("red","green3","dodgerblue",
          "red3","green4","blue2",
          "darkred")
plotGRanges(seg)
```

```{r toyranges}
n <- 50
gr <- GRanges(
  seqnames=sort(sample(c("chr1","chr2"), n, TRUE)),
  IRanges(start=round(runif(n, 1, 500-20+1)), width=20)
)
suppressWarnings({
  seqlengths(gr) <- seqlengths(seg)
})
gr <- gr[!(seqnames(gr) == "chr2" & end(gr) > 400)]
gr <- sort(gr)
idx <- findOverlaps(gr, seg, select="first")
gr$state <- seg$state[idx]
gr$state_col <- seg$state_col[idx]
plotGRanges(gr)
```

```{r}
gr_prime <- nullranges::segBootstrapRanges(seg, gr, L_b=100, R=1)[[1]]
# plotGRanges(gr_prime)
```
